<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  

  <title>Cloud and Serverless Turkey Ramazan Özel [TR]</title>
  <meta name="description" content="Merhabalar,

">
  <meta name="author" content="denizg">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Cloud and Serverless Turkey Ramazan Özel [TR]">
  <meta name="twitter:description" content="Merhabalar,

">
  
  <meta name="twitter:image" content="/images/favicons/favicon-194x194.png" />

  <meta property="og:type" content="article">
  <meta property="og:title" content="Cloud and Serverless Turkey Ramazan Özel [TR]">
  <meta property="og:description" content="Merhabalar,

">
  <meta property="og:image" content="/images/favicons/favicon-194x194.png" />

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" href="/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <link rel="stylesheet" href="/css/main.css?1681656674222981100">
  <link rel="canonical" href="http://localhost:4000/2020/cloud-and-serverless-turkey-ramazan-ozel/">
  <link rel="alternate" type="application/rss+xml" title="Deniz G" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="link to home of Deniz G">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">Deniz G</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">Bilingual Blog: Turkish and English on Software and Life.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="link to Deniz G blog" class="blog-button">Blog</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">

            

            

            

            
              <!-- GitHub -->
              <li class="navigation__item">
                <a href="https://www.github.com/dgempiuc" title="dgempiuc on GitHub" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>
            

            
              <!-- Email -->
              <li class="navigation__item">
                <a href="mailto:dgempiuc@gmail.com" title="Email dgempiuc@gmail.com" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>
            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>

            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-07-05 14:49" class="post-meta__date date">5 Jul 2020</time>
      
      &#8226; <span class="post-meta__tags">on <a href="/tags/#software">software</a></span>
      
    </div>
    <h1 class="post-title">Cloud and Serverless Turkey Ramazan Özel [TR]</h1>
  </header>

  <section class="post">
    <p>Merhabalar,</p>

<p>Ramazan ayı boyunca Cloud and Serverless Turkey meetup ekibi haftada bir yada iki olmak üzere, ben gibi Cloud’a yeni başlayacaklar için çok yararlı olacak online etkinlikler düzenledi. Ben de dinlerken bazı önemli gördüğüm noktaları not aldım ve blog’uma aktarmak için şu an zaman bulabildim.</p>

<p><a href="https://kommunity.com/cloud-and-serverless-turkey/events/serverless-turkiye-ile-ramazan-ozel-134b33a1">Etkinlik Sayfası</a></p>
<ul>
  <li>6 Mayıs Çarşamba - AWS Global infrastructure: Uygulamamı us-east-1’a deploy ettim patladı, orucum kabul olur mu?</li>
  <li>12 Mayıs Salı - DevOps vs SRE: hangisi daha çok sevap point kazandırır?</li>
  <li>15 Mayıs Cuma - Cold Start ve diğer Serverless problemleri: İstemeden Cold Start’a yakalandım, orucum bozulmuş olur mu?</li>
  <li>18 Mayıs Pazartesi - Container vs Serverless: Containerlar ile Serverless fonksiyonları beraber kullanmak caiz midir?</li>
  <li>21 Mayıs Perşembe - Cloud’a nasıl başlarım: Cloud korkularımı yenmek için ne yapmayalım?</li>
</ul>

<p><strong>AWS Bulut Altyapısı Bileşenler: Zone, Region, CDN ve daha fazlası</strong></p>

<p><a href="https://www.youtube.com/watch?v=Sn4sSTtYj-A" title="AWS Bulut Altyapısı Bileşenler"><img src="http://img.youtube.com/vi/Sn4sSTtYj-A/0.jpg" alt="AWS Bulut Altyapısı Bileşenler" /></a></p>

<p>AWS altyapısı ile ilgili kavramları (Regions, AZ-Availability Zones, Local Zones, Point of Presence, Network) görsel olarak anlatan bir site.</p>

<p><a href="https://infrastructure.aws" target="_blank">infrastructure.aws</a></p>

<p>Region seçimindeki en büyük fark lateny. Türkiye için genelde Frankfurt tercih ediliyor. (60-80ms round trip latency) Mesela Dublin için 130ms. Rakamların anlam kazanması için; insanın gözünü açıp kapatması 300ms sürüyor.</p>

<p>Bulunduğunuz bölgeden region’lara olan latency’i hesaplayan bir site. Region seçiminde faydalı olabilir.</p>

<p><a href="https://www.cloudping.info/" target="_blank">cloudping.info</a></p>

<p>Peki region, latency harici neye göre seçilmeli? Yeni servis ya da yeni eklenen özellik hemen tüm region’lara gelmiyor. Genelde avrupa için ilk region olan Dublin’e geliyor. Tabii, müşteri profiline göre de bir etkisi var. IoT sektörü oralarda daha gelişmiş olduğu için IoT özellikleri genelde Frankfurt’a geliyor.</p>

<p>Her servisin fiyatı her region’da aynı değil, maliyete göre fiyatlandırma yapılıyor; enerji maliyeti, insan gücü maliyeti vs. Mesela Amerika’da enerji, Amazon’un kendi güneş panellerinden üretildiği için oradaki servisler daha ucuz.</p>

<p>AZ-Availability Zones = Datacenter Cluster</p>

<p>Az to AZ latency: 2-4 ms</p>

<p>Veriyi region’a yükleyince, arka planda birden cok AZ’ye replica ediyor. Yüzde 99,9…(9 tane 9) availability sağlıyor. Veri sadece o region’da, regionlar arası kopyalama yok. Böylece Türkiye bir gün region olursa, veri Türkiye dışına çıkmıyor, yani KVKK’ya uyuyor.</p>

<p>Local Zone= Tek datacenter ve bir region’a bağlı. Altyapıyı hızlı şekilde kurmak için, tüm servisler yok, amaç ihtiyaca göre hızlı cevap verecek şekilde tasarlamak, diğer türlü AZ tasarlamak zor.</p>

<p>Point of Presence ile latency’i azaltmaya yönelik region’a giden yolda cache noktaları var.</p>

<p>Spot instance: Çok kullanılmayan makinelerde (mesela milanda daha az kullanıcı varsa) daha ucuz maliyetle servisleri kullanabilme imkanı var, açık artırma gibi. Diğer kullanım yöntemleri on-demand ve reserved instances.</p>

<p>Ya region fail olursa? O zaman region bazında high availability seçeceksin. Uygulamayı iki regiona dağıtacaksın. Bu da x2 maliyet demek. Ortada bir trade-off var: risk mi maliyet mi? Ama zoned-based architecture yeterince güvenli.</p>

<p>AWS neye göre region kuruyor? return of invesment: yatırımı kaç senede cıkarabilirim?</p>

<p>AWS re:Invent 2016: Amazon Global Network Overview with James Hamilton</p>

<p><a href="https://www.youtube.com/watch?v=uj7Ting6Ckk" target="_blank">AWS arkasındaki mühendislik</a></p>

<p><strong>DevOps ve SRE farkı nedir?</strong></p>

<p><a href="https://www.youtube.com/watch?v=WiYBsY_6FFU" title="DevOps ve SRE farkı nedir?"><img src="http://img.youtube.com/vi/WiYBsY_6FFU/0.jpg" alt="DevOps ve SRE farkı nedir?" /></a></p>

<p>Farklarında önce bir benzerliği, ikisi de cross-functional team.</p>

<p>DevOps, developerlar işini yapabilsin diye kod hariç herşeyi yapan kesim. Yazılım sektörüyle ilgili teknik pratikleri içerir.</p>

<p>SRE-Site Reliability Engineer, ilk olarak Google tarafından uygulanmıştır. google’ın tanımına göre yazılımcıya SysAdmin işlerini vermeye deniyor.</p>

<p>SRE implements DevOps.</p>

<p>SRE’in ana görevi reliability, yani üründe çıkan soruları çözerek ürünün ayakta sağlam şekilde olmasında sorumlu, bunu da Scalability, Security, Monitoring, Automation gibi DevOps süreçleriyle sağlıyor. Burası işinin %50’si. Kalan %50’si ile yazılım yaparak ürün geliştirme. Ama bu geliştirme domain’e yönelik değil, developer’ların kullanacağı ürünler. Yani infrastructure development.</p>

<p>SRE, şirket içindeki en güçlü yazılım mühendisleridir,koçluk yaparlar, best practice’leri anlatırlar, 2-3 ay bir takıma giderler ve reliability olmayı öğretirler.</p>

<p>Altyapıdaki know-how’ı almak, kişileri bu altyapıya entegre etmek aylar sürebilir. SRE’in altyapıda kullanılan herşey hakkında, normalin ilerisinde bilgisi olmalıdır.</p>

<p>Altyapı çok sancılı bir süreç. Herşeyi tasarladın yaptın ettin ama buna adapte olacak kimse yoksa, yine reliability’in kırılıyor.</p>

<p>Developer’ların kafkayı nasıl scale edeceğini bilmesi gerekmiyor, ama oraya nasıl mesaj atacak bilebilmeli. Buradaki ownership, takımlarda değil SRE’de. Developer nasıl kullanacağını biliyor ama nasıl çalışıyor bilmiyor. Serverless’a yakın bir sistem sunuluyor aslında. Shared-Responsibility.</p>

<p><a href="https://jbd.dev/prod-readiness/" target="_blank">https://jbd.dev/prod-readiness/</a></p>

<p><a href="https://medium.com/google-cloud/production-guideline-9d5d10c8f1e" target="_blank">https://medium.com/google-cloud/production-guideline-9d5d10c8f1e</a></p>

<p><strong>FaaS - Serverless (AWS Lambda) Problemleri ve Çözümleri</strong></p>

<p><a href="https://www.youtube.com/watch?v=keNdLKPi2gQ" title="FaaS - Serverless (AWS Lambda) Problemleri ve Çözümleri"><img src="http://img.youtube.com/vi/keNdLKPi2gQ/0.jpg" alt="FaaS - Serverless (AWS Lambda) Problemleri ve Çözümleri" /></a></p>

<p>AWS Lambda, tam karşılığı FaaS, büyük uygulamaları input ve output olacak şekilde küçük function’lara bölüyoruz. Nerede nasıl hangi serviste çalışacak, scalabilty’si bizi ilgilendirmiyor, bunlarla serverless ilgileniyor. Aslında adı da buradan geliyor, server’ları bizden soyutladığı için serverless deniliyor, yoksa arka planda yine server’larda çalışıyor. AWS Lambda, stateless bir servis. Ayrıca event-driven. Mesela S3’e dosya eklendi, bu create event yaratır, lambda bunu yakalayarak trigger’lanabilir. Event nasıl gelecek, nasıl işleyeceğim diye endişelenmiyorsun, geldiği an işliyorsun ne güzel.</p>

<p>Lambda Problemleri</p>

<p><strong>Cold Start</strong>; Initialize olma süresine cold start deniyor. Lambda container’lar üzerinde çalışıyor. Uygulamaya request geldiğinde, lambda önce hazırda varsa ona yonlendiriyor, yoksa yeni container ayağa kaldırıyor. Container’lar hızlı ayağa kalkıyor ama buradaki asıl sorun uygulamanın ayağa kalkması. Mesela spring saniyelerce sürüyor. Bu genelde Java sorunu, Spring’i lambda’ya olduğu gibi taşırsan oooooppppsssss.</p>

<p>Lambda işi bitince, container’ı freeze ediyor, request gelince tekrar unfreeze ediyor. Belli süre request gelmezse, buna zaten istek gelmiyor deyip kendini kapatıyor. Bu yüzden stateless olsun deniyor lambda’larınız.</p>

<p>Bazı çözüm yolları;</p>
<ul>
  <li>İstenilirse istenen sayıda container ayakta tutulur. Negative effect: pricing. Zaten EC2 yerine kullanma nedeni ucuza getirmek, sadece function’ın çalıştığı süredeki kaynaklar için ödeme yapılıyor.</li>
  <li>Boş/dummy mesajlar gönderilerek kapanması önlenebilir, warmup.</li>
</ul>

<p><strong>At Least One Delivery Problem</strong>. Tek bir request için bir kez çalışması beklenen function’da, iki kere calısma yaşabiliyor. Çünkü exactly once maliyetli, bunu sunars throughput’u düşüyor. Idempodent işlemler sorun olmaz ama ödeme gibi önemli islemlerde birden fazla olamaz. Distributed, genelde at-least-one sunuluyor, aynı durum standart SQS’te de var.</p>

<p>Step functions bunu cozuyor.</p>

<p><strong>Lambda</strong>, çok fazla scale edilirse <em>concurrent</em> calışarak, on-demand servisere mesela RDS’e birçok connection açılabiliyor. Lambda’da bu, concurrent execution limit ile sınırlanabiliyor, peki ama gercekten scale etmesi gerekirse o zaman edemez. RDS özelinde bu, RDS proxy ile direkt DB’ye connection açmak yerine proxy’e açılarak çözülüyor. Proxy, fiziksel connectionları yönetiyor, bu sayede yükün çoğu proxy’e biniyor.</p>

<p>OpsGenie 40.000 $’lık fail hikayesi. Cloudwatch’a log geldikçe lambda yakalıyor ve graylog’a gönderiyor.
Graylog down oluyor. buraya gönderilemeyen mesajlar dead letter queue’da birikiyor. Lambda DLQ’dan tekrar tekrar trigger oluyor. 2 hafta boyunca queue büyüdükçe lambda sürekli scale oluyor. Sonuç 40bin dolar fatura.</p>

<p><strong>Monitoring ve Debugging</strong></p>

<p>Lambda dışarıdan connection kabul etmiyor. Nedeni VPC, ona adres atamıyor. Ancak API Gateway ile dışarıdan erişilebilir.</p>

<p>Lambda yalnızca request’i işlerken aktif, o yüzden iş bitince arkada logu gonderecek bir şey yok. Her an ölebilir, donabilir, loglar da gönderilmeden kalabilir. mesela Elasticsearch API ile göndermek uygulamayı ağırlaştırır, o yüzden bir seçenek değil.</p>

<p>Uygulamada debugging nasıl oluyorr? IDE, uygulamaya network connection açıyor. Debug ile alakalı komutlar, bu TCP connection üzerinden gidiyor. Lambda da dışarıdan bağlanamıyosun, ee? Thundra, bu workaround’da çalışıyor. IDE ve lambda ortada broker’da buluşuyor. Kullanıcılar local IDE’sinden debug edebiliyor.</p>

<p><a href="https://medium.com/@serhatcan/how-aws-lambda-team-made-my-two-years-old-talk-completely-irrelevant-1c74c528ca78" target="_blank">How AWS Lambda team made my two years old talk completely irrelevant by Serhat Can</a></p>

<p><strong>Bulutta Yüksek Performanslı ve Verimli Sistem Tasarlama</strong></p>

<p><a href="https://www.youtube.com/watch?v=nuOCuAwQwvo" title="Bulutta Yüksek Performanslı ve Verimli Sistem Tasarlama"><img src="http://img.youtube.com/vi/nuOCuAwQwvo/0.jpg" alt="Bulutta Yüksek Performanslı ve Verimli Sistem Tasarlama" /></a></p>

<ul>
  <li>Metrics</li>
</ul>

<p>İşler iyi gitmiyorsa problemin nerede olduğu metric’lerden anlaşılır. O yüzden iyi bir sistem tasarlarken metric toplamak, özellikle hangi metric’ler toplanacak önemli. Mesela dışarıya API sunuluyorsa bu metricler latency, erros, CPU/memory/IO olabilir. Latency yüksekse client, sistem performansından memnun olmaz demektir, bu anlaşılır.
Avg latency’e bakmak outlier’ları gizler, bunun için performansa bakılırken avg latency yerine p90, p99, max latency ile ilgilenilmeli. (p90=percentile 90. x latency ile alakalı metric’lerin yüzde90’ı x altında.)
Max latency, sistem en kötü durumda ne kadar cevap veriyor demek, bu yüzden max’a başvurmak en iyisi.</p>

<p>Client Error (HTTP 4xx) ignore edilebilir, ama sık sık gelirse incelenmesi gerekebilir. Server Error (5xx) aslında önemli, bu error’lara alarm kurmak iyi bir pratik.</p>

<p>Sunucu üzerinde calısan uygulamalar icin CPU/memory/IO. Eğer memory, sınırlarda dolaşıyorsa out-of-memory yemesi işten bile değil. IO, sürekli diske yazan okuyan işlemler, belki bir kere okuyup cacheleyerek disk üzerindeki baskıyı azaltmak yerine sürekli diskten okuma, sistem yavaşlığına sebep olabilir. Bu metric ile anlaşılabilir.</p>

<p>Servislere özel metricler; redis, lambda, sqs, knesis, dynamodb’a özel metricler. mesela sqs’de # msg visible, bir anda artarsa kuyrukta consume hızı yavaş, ileride sorun yaratabilir uyarı demek. Redis icin eviction (cache belli bir memory sınırına ulaşınca, kendisini sağlıklı tutabilmek için cache’deki varolan itemlar’den evict etme).
Eviction’ların çok olması, memory’nin yetersiz olduğuna ya da gereksiz yere çoğu şeyi cache’de tuttugumuz anlamına gelebilir.</p>

<ul>
  <li>Caching</li>
</ul>

<p>Amaç, optimizasyon ve daha iyi performans. Ne tür cache’lemeler yapılabilir?</p>

<p>Read’ler icin diske gitmeden de sonuç dönebilme için cache-layer. 
Cache layer = Local Cache (remote cache’e network call atmasına gerek kalmadan) + Remote Cache(Redis, ElastiCache vb.)</p>

<p>negative cache , positive cache. cache hata bulunursa kullanıcıya hata mı dönülsün?</p>

<p>inline cache</p>

<p>side cache=  cache ve db aynı yerdeyse side cache mesela dax, dynamodb önündeki cache. tek bir layer gibi geliyor.</p>

<p>Thundering herd problem: Cachede data yok, 100 request aynı anda geldi, 100’ü de aynı anda DB’ye gidecek demek. Bunun yerine cache kısmında, cache’den arka servise erişilirken lock tutulup sadece birisi DB’ye erişebilir. Böylece arkadaki servis boğulmamış olur.</p>

<ul>
  <li>IO</li>
</ul>

<p>Async IO ve Non-blocking IO benzer ama detayda farklı. Async için, o thread o işi yapmak i.in baska thread’e paslıyor. Arkadaki işi paylaştığı thread’ler birbirini bekleyeebilir thread pool’da. Mesela 100 thread’lik bir pool. 101. thread pool’u bekleyecek.</p>

<p>Non-blocking’de, beklemeden ziyade OS seviyesinde select/pool, epoll ile işlemler.</p>

<p>Connection, elden geldiğince reuse edilmeli. keep-alive. Https için, birden fazla round trip oluyor, mesela sertikayı al gibi bir overhead. http/2, http/1 üzerine avantajlı, client’ın istemesine gerek olmadan server-push mantığı sağlıyor.</p>

<p>İletişim protokolü uygunsa REST değil de gRPC. gRPC, default http/2 üzerinde. REST, genelde json ve xml formatında ama çok sıkıştırılmış data değil. gRPC’de data size’ı çok küçük, boylece daha az data gidip geldiği icin performanstan kazanılır.</p>

<p>CDN kullanılmalı. DNS resolution aşamasında, CDN edge seçimi gerceklesiyor. Web sayfası icin ciddi performans sergiliyor, aksi takdirde dünyanın öbür ucuna gidip gelmesi bayağı bir network delay olur.</p>

<ul>
  <li>Redis</li>
</ul>

<p>Redis Pipelining: redis’e tek tek gitmek yerine batch ile gitmek. Böylece tek seferde gönderilir, rediste internal olarak tek tek işlenir.</p>

<p>Persistent olması istenmiyorsa kapatılmalı. RDB snapshot ile, periyodik aralıklarda redisin snapshot’ı diske yazılıyor, default bu var.</p>

<p>Disk Swap; memorydeki data diske transfer edilirse yavaslık olur, disk swap kapatılması iyi olur.</p>

<p>Komutun complexity’sinin farkında olunmalı. O(n) gibi bir komut için milyonlara item varsa, bu komut sn’ler sürebilir. Redis’in sitesinde hangi komutun ne kadar karmaşıklıkta olduğu yazıyor.</p>

<ul>
  <li>ElasticSearch</li>
</ul>

<p>Reindex’lemek. Eğer çok fazla update/delete varsa index’i yenilemek icin önemli.
Yine disk swap edilmeli. Profiling api ile, query planı görülebilir. Query hakkında nasıl çalıştığı hakkında bilgi sağlayarak bir inside verir, yani profiling ile monitoring.</p>

<ul>
  <li>Event-Driven Architecture</li>
</ul>

<p>Böyle tasarlanmasının faydası? API, gelen istekle datayı yazmak icin beklememiş olacak. Baska servise delege edecek. Hatta servis, batch olarak yazarak yazdığı servisi daha fazla yormamış olur. Hem de hata durumlarında daha kolay çıkılır.</p>

<ul>
  <li>Replicate</li>
</ul>

<p>Kendisine daha yakın storage’den alması. Data locality ve failover mekanizması.</p>

<ul>
  <li>Recover</li>
</ul>

<p>Sistemin dayanıklı olmasını sağlıyor. Periyodik olarak sistem snapshot’ı alınabilir.</p>


  </section>
  
</article>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2023 denizg. All rights reserved.</span>
</footer>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1681656674222981100"></script>


    </div>
  </body>
</html>